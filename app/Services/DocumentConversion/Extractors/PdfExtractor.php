<?php

declare(strict_types=1);

namespace App\Services\DocumentConversion\Extractors;

use App\Contracts\DocumentExtractorInterface;
use App\DTOs\DocumentContent;
use App\DTOs\DocumentMetadata;
use Exception;
use Illuminate\Support\Facades\Log;
use Smalot\PdfParser\Config;
use Smalot\PdfParser\Parser;

/**
 * Extracteur de contenu depuis des fichiers PDF
 */
final class PdfExtractor implements DocumentExtractorInterface
{
    private const array SUPPORTED_MIMES = [
        'application/pdf',
    ];

    /**
     * Patterns pour ignorer les éléments non désirés
     */
    private const array IGNORED_PATTERNS = [
        '/^Page \d+/i',                    // Numéros de page
        '/^\d+$/',                         // Chiffres seuls
        '/^- \d+ -$/',                     // Format de pagination
        '/^Page \d+ of \d+/i',             // Page X of Y
        '/^Copyright/i',                   // Mentions de copyright
        '/^Confidential/i',                // Mentions confidentielles
        '/^www\./i',                       // URLs en bas de page
        '/^http[s]?:\/\//i',              // URLs
        '/^\d{1,2}\/\d{1,2}\/\d{4}$/',   // Dates
        '/^\d{4}-\d{2}-\d{2}$/',          // Dates ISO
        '/^Powered by/i',                  // Générateurs
        '/^Generated by/i',                // Générateurs
        '/^Table of Contents/i',           // Table des matières brute
        '/^Acknowledgements?/i',           // Remerciements
        '/^Bibliography/i',                // Bibliographie
        '/^References/i',                  // Références
    ];

    public function supports(string $filePath): bool
    {
        $mimeType = mime_content_type($filePath);

        return in_array($mimeType, self::SUPPORTED_MIMES, true);
    }

    public function extract(string $filePath, array $options = []): DocumentContent
    {
        try {
            $config = app(Config::class);
            $config->setDataTmFontInfoHasToBeIncluded(true);
            $parser = new Parser([], $config);

            $document = $parser->parseFile($filePath);

            $metadata = $this->extractMetadata($document);

            $rawText = $this->extractTextFromPages($document, $options);

            $rawText = $this->ensureUtf8Encoding($rawText);

            $cleanedText = $this->cleanText($rawText, $options);

            $options['filePath'] = $filePath;

            $content = new DocumentContent(
                rawText: $cleanedText,
                metadata: $metadata,
                options: $options,
            );

            Log::info('PDF extracted successfully', [
                'file' => $filePath,
                'pages' => $metadata->pageCount,
                'text_length' => mb_strlen($cleanedText),
                'first_page_skipped' => $options['skipFirstPage'] ?? false,
            ]);

            return $content;

        } catch (Exception $e) {
            Log::error('Error extracting PDF', [
                'file' => $filePath,
                'error' => $e->getMessage(),
            ]);

            throw new Exception('Erreur lors de l\'extraction du PDF: ' . $e->getMessage());
        }
    }

    /**
     * Extrait les métadonnées du document
     */
    private function extractMetadata($document): DocumentMetadata
    {
        $details = $document->getDetails();

        return new DocumentMetadata(
            title: $details['Title'] ?? null,
            author: $details['Author'] ?? null,
            subject: $details['Subject'] ?? null,
            creator: $details['Creator'] ?? null,
            producer: $details['Producer'] ?? null,
            creationDate: $details['CreationDate'] ?? null,
            modificationDate: $details['ModDate'] ?? null,
            pageCount: count($document->getPages()),
        );
    }

    /**
     * Extrait le texte des pages du PDF (en ignorant la première page si demandé)
     */
    private function extractTextFromPages($document, array $options): string
    {
        $pages = $document->getPages();
        $skipFirstPage = $options['skipFirstPage'] ?? false;
        $textParts = [];

        foreach ($pages as $pageNumber => $page) {
            if ($skipFirstPage && $pageNumber === 0) {
                continue;
            }

            $pageText = $page->getText();
            if (!empty(mb_trim($pageText))) {
                $textParts[] = $pageText;
            }
        }

        return implode("\n\n", $textParts);
    }

    /**
     * Assure que le texte est en UTF-8 valide
     */
    private function ensureUtf8Encoding(string $text): string
    {
        $encoding = mb_detect_encoding($text, ['UTF-8', 'ISO-8859-1', 'Windows-1252', 'ASCII'], true);

        if ($encoding && $encoding !== 'UTF-8') {
            $text = mb_convert_encoding($text, 'UTF-8', $encoding);
        }

        $text = mb_convert_encoding($text, 'UTF-8', 'UTF-8');

        return $this->fixEncodingIssues($text);
    }

    /**
     * Corrige les problèmes d'encodage courants dans les PDFs
     */
    private function fixEncodingIssues(string $text): string
    {
        $replacements = [
            "\xEF\xAC\x81" => 'fi',  // ligature fi
            "\xEF\xAC\x82" => 'fl',  // ligature fl
            "\xEF\xAC\x80" => 'ff',  // ligature ff
            "\xEF\xAC\x83" => 'ffi', // ligature ffi
            "\xEF\xAC\x84" => 'ffl', // ligature ffl
            "\xEF\xAC\x85" => 'ft',  // ligature ft
            "\xEF\xAC\x86" => 'st',  // ligature st

            'ﬁ' => 'fi',
            'ﬂ' => 'fl',
            'ﬀ' => 'ff',
            'ﬃ' => 'ffi',
            'ﬄ' => 'ffl',
            'ﬅ' => 'ft',
            'ﬆ' => 'st',

            "\xE2\x80\x98" => "'",  // '
            "\xE2\x80\x99" => "'",  // '
            "\xE2\x80\x9C" => '"',  // "
            "\xE2\x80\x9D" => '"',  // "
            "\xC2\xAB" => '"',      // «
            "\xC2\xBB" => '"',      // »

            "\xE2\x80\x93" => '-',  // –
            "\xE2\x80\x94" => '-',  // —
            "\xE2\x88\x92" => '-',  // −

            "\xC2\xA0" => ' ',      // Espace insécable
            "\xE2\x80\xAF" => ' ',  // Espace fine insécable

            "\xEF\xBF\xBD" => '',   // �
        ];

        return str_replace(array_keys($replacements), array_values($replacements), $text);
    }

    /**
     * Nettoie le texte extrait
     */
    private function cleanText(string $text, array $options): string
    {
        $text = $this->fixEncodingIssues($text);

        $lines = explode("\n", $text);
        $cleanedLines = [];

        foreach ($lines as $line) {
            $line = mb_trim($line);

            if (empty($line)) {
                continue;
            }

            if (mb_strlen($line) < 3 && !$this->isImportantShortLine($line)) {
                continue;
            }

            if ($this->shouldIgnoreLine($line, $options)) {
                continue;
            }

            $cleanedLines[] = $line;
        }

        return implode("\n", $cleanedLines);
    }

    /**
     * Vérifie si une ligne courte est importante
     */
    private function isImportantShortLine(string $line): bool
    {
        return preg_match('/^[A-Z0-9\s\-\.]{1,3}$/', $line) && !preg_match('/^\d+$/', $line);
    }

    /**
     * Vérifie si une ligne doit être ignorée
     */
    private function shouldIgnoreLine(string $line, array $options): bool
    {
        if ($options['ignorePageNumbers'] ?? true) {
            if ($this->isPageNumber($line)) {
                return true;
            }
        }

        foreach (self::IGNORED_PATTERNS as $pattern) {
            if (preg_match($pattern, $line)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Vérifie si la ligne est un numéro de page
     */
    private function isPageNumber(string $line): bool
    {
        return preg_match('/^(Page\s+)?\d+(\s+of\s+\d+)?$/i', $line) ||
            preg_match('/^-\s*\d+\s*-$/', $line) ||
            (is_numeric($line) && mb_strlen($line) <= 3);
    }

    public function getSupportedMimeTypes(): array
    {
        return self::SUPPORTED_MIMES;
    }
}

<?php

declare(strict_types=1);

namespace App\Services\DocumentConversion\Extractors;

use App\Contracts\DocumentExtractorInterface;
use App\DTOs\DocumentContent;
use App\DTOs\DocumentMetadata;
use Exception;
use Illuminate\Support\Facades\Log;
use Smalot\PdfParser\Config;
use Smalot\PdfParser\Parser;

/**
 * Extracteur de contenu depuis des fichiers PDF
 */
final class PdfExtractor implements DocumentExtractorInterface
{
    private const array SUPPORTED_MIMES = [
        'application/pdf',
    ];

    /**
     * Patterns pour ignorer les éléments non désirés
     */
    private const array IGNORED_PATTERNS = [
        '/^Page \d+/i',                    // Numéros de page
        '/^\d+$/',                         // Chiffres seuls
        '/^- \d+ -$/',                     // Format de pagination
        '/^Page \d+ of \d+/i',             // Page X of Y
        '/^Copyright/i',                   // Mentions de copyright
        '/^Confidential/i',                // Mentions confidentielles
        '/^www\./i',                       // URLs en bas de page
        '/^http[s]?:\/\//i',              // URLs
        '/^\d{1,2}\/\d{1,2}\/\d{4}$/',   // Dates
        '/^\d{4}-\d{2}-\d{2}$/',          // Dates ISO
        '/^Powered by/i',                  // Générateurs
        '/^Generated by/i',                // Générateurs
        '/^Table of Contents/i',           // Table des matières brute
        '/^Acknowledgements?/i',           // Remerciements
        '/^Bibliography/i',                // Bibliographie
        '/^References/i',                  // Références
    ];

    public function supports(string $filePath): bool
    {
        $mimeType = mime_content_type($filePath);

        return in_array($mimeType, self::SUPPORTED_MIMES, true);
    }

    public function extract(string $filePath, array $options = []): DocumentContent
    {
        try {
            $config = app(Config::class);
            $config->setDataTmFontInfoHasToBeIncluded(true);
            $parser = new Parser([], $config);

            $document = $parser->parseFile($filePath);

            // Extraire les métadonnées
            $metadata = $this->extractMetadata($document);

            // Extraire le texte brut
            $rawText = $document->getText();

            // Nettoyer le texte
            $cleanedText = $this->cleanText($rawText, $options);

            // Créer le DTO
            $content = new DocumentContent(
                rawText: $cleanedText,
                metadata: $metadata,
                options: $options,
            );

            Log::info('PDF extracted successfully', [
                'file' => $filePath,
                'pages' => $metadata->pageCount,
                'text_length' => mb_strlen($cleanedText),
            ]);

            return $content;

        } catch (Exception $e) {
            Log::error('Error extracting PDF', [
                'file' => $filePath,
                'error' => $e->getMessage(),
            ]);

            throw new Exception('Erreur lors de l\'extraction du PDF: ' . $e->getMessage());
        }
    }

    /**
     * Extrait les métadonnées du document
     */
    private function extractMetadata($document): DocumentMetadata
    {
        $details = $document->getDetails();

        return new DocumentMetadata(
            title: $details['Title'] ?? null,
            author: $details['Author'] ?? null,
            subject: $details['Subject'] ?? null,
            creator: $details['Creator'] ?? null,
            producer: $details['Producer'] ?? null,
            creationDate: $details['CreationDate'] ?? null,
            modificationDate: $details['ModDate'] ?? null,
            pageCount: count($document->getPages()),
        );
    }

    /**
     * Nettoie le texte extrait
     */
    private function cleanText(string $text, array $options): string
    {
        $lines = explode("\n", $text);
        $cleanedLines = [];

        foreach ($lines as $line) {
            $line = mb_trim($line);

            // Ignorer les lignes vides
            if (empty($line)) {
                continue;
            }

            // Ignorer les lignes trop courtes (sauf si importantes)
            if (mb_strlen($line) < 3 && !$this->isImportantShortLine($line)) {
                continue;
            }

            // Ignorer les patterns non désirés
            if ($this->shouldIgnoreLine($line, $options)) {
                continue;
            }

            $cleanedLines[] = $line;
        }

        return implode("\n", $cleanedLines);
    }

    /**
     * Vérifie si une ligne courte est importante
     */
    private function isImportantShortLine(string $line): bool
    {
        // Lignes avec lettres majuscules et chiffres
        return preg_match('/^[A-Z0-9\s\-\.]{1,3}$/', $line) && !preg_match('/^\d+$/', $line);
    }

    /**
     * Vérifie si une ligne doit être ignorée
     */
    private function shouldIgnoreLine(string $line, array $options): bool
    {
        // Ignorer les numéros de page si demandé
        if ($options['ignorePageNumbers'] ?? true) {
            if ($this->isPageNumber($line)) {
                return true;
            }
        }

        // Vérifier les patterns d'ignorance
        foreach (self::IGNORED_PATTERNS as $pattern) {
            if (preg_match($pattern, $line)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Vérifie si la ligne est un numéro de page
     */
    private function isPageNumber(string $line): bool
    {
        return preg_match('/^(Page\s+)?\d+(\s+of\s+\d+)?$/i', $line) ||
            preg_match('/^-\s*\d+\s*-$/', $line) ||
            (is_numeric($line) && mb_strlen($line) <= 3);
    }

    public function getSupportedMimeTypes(): array
    {
        return self::SUPPORTED_MIMES;
    }
}

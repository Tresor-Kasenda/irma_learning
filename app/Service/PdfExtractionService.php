<?php

namespace App\Service;

use Exception;
use Intervention\Image\Laravel\Facades\Image;
use Smalot\PdfParser\Config;
use Smalot\PdfParser\Parser;
use Spatie\PdfToImage\Pdf;

class PdfExtractionService
{
    private array $ignoredPatterns;
    private array $codePatterns;
    private array $tablePatterns;

    public function __construct()
    {
        $this->setupPatterns();
    }

    private function setupPatterns(): void
    {
        $this->ignoredPatterns = [
            '/^Page \d+/i',
            '/^\d+$/',
            '/^- \d+ -$/',
            '/^Page \d+ of \d+/i',
            '/^Copyright/i',
            '/^Confidential/i',
            '/^www\./i',
            '/^http[s]?:\/\//i',
            '/^\d{1,2}\/\d{1,2}\/\d{4}$/',
            '/^\d{4}-\d{2}-\d{2}$/',
            '/^Powered by/i',
            '/^Generated by/i',
        ];

        $strictCodePatterns = [
            '/^(function|def|class|public|private|protected)\s/',
            '/^(if|else|for|while|switch|case)\s*\(/',
            '/^(import|include|require|from)\s/',
            '/^(var|let|const|int|string|bool)\s/',
            '/^\$[a-zA-Z_][a-zA-Z0-9_]*\s*=/',
            '/^console\.(log|error|warn)/',
            '/^#include|^#define/',
        ];

        $lenientCodePatterns = [
            '/[{}();=<>]/',
            '/^\s*[\w]+\s*\(/',
            '/^\s*[\w]+\s*=/',
        ];

        $this->codePatterns = array_merge($strictCodePatterns, $lenientCodePatterns);

        $this->tablePatterns = [
            '/\|.*\|.*\|/',
            '/\t.*\t.*\t/',
            '/^\s*\d+\.\s+.*\d+.*$/',
        ];
    }

    /**
     * Extrait le contenu d'un PDF et retourne les données formatées pour un chapitre
     */
    public function extractPdfContent(string $pdfPath, array $options = []): array
    {
        $defaultOptions = [
            'extractImages' => true,
            'extractTables' => true,
            'extractCode' => true,
            'createTableOfContents' => true,
            'generateCoverImage' => true,
            'ignorePageNumbers' => true,
            'ignoredPages' => [],
        ];

        $options = array_merge($defaultOptions, $options);

        try {
            $config = app(Config::class);
            $config->setDataTmFontInfoHasToBeIncluded(true);
            $parser = new Parser([], $config);

            $document = $parser->parseFile($pdfPath);
            $metadata = $this->extractMetadata($document);

            $extractedImages = [];
            if ($options['extractImages']) {
                $extractedImages = $this->extractImagesFromPdf($pdfPath);
            }

            $coverImagePath = '';
            if ($options['generateCoverImage']) {
                $coverImagePath = $this->generateCoverImage($pdfPath);
            }

            $pages = $document->getPages();
            $markdownContent = $this->processPages($pages, $options);

            $tableOfContents = [];
            if ($options['createTableOfContents']) {
                $tableOfContents = $this->generateTableOfContents($markdownContent);
            }

            return [
                'title' => $metadata['title'] ?? 'Document PDF',
                'description' => $metadata['subject'] ?? 'Contenu extrait automatiquement depuis un PDF',
                'content' => $this->finalizeMarkdown(
                    $markdownContent,
                    $metadata,
                    $coverImagePath,
                    $tableOfContents,
                    $extractedImages
                ),
                'metadata' => [
                    'pdf_info' => $metadata,
                    'extracted_images' => $extractedImages,
                    'cover_image' => $coverImagePath,
                    'table_of_contents' => $tableOfContents,
                    'extraction_options' => $options,
                ],
                'estimated_duration' => $this->calculateEstimatedDuration($markdownContent),
            ];

        } catch (Exception $e) {
            throw new Exception('Erreur lors de l\'extraction du PDF : ' . $e->getMessage());
        }
    }

    private function extractMetadata($document): array
    {
        $details = $document->getDetails();

        return [
            'title' => $details['Title'] ?? 'Document PDF',
            'author' => $details['Author'] ?? null,
            'subject' => $details['Subject'] ?? null,
            'creator' => $details['Creator'] ?? null,
            'producer' => $details['Producer'] ?? null,
            'creation_date' => $details['CreationDate'] ?? null,
            'modification_date' => $details['ModDate'] ?? null,
            'page_count' => count($document->getPages()),
        ];
    }

    private function extractImagesFromPdf(string $pdfPath): array
    {
        $extractedImages = [];

        try {
            $pdf = new Pdf($pdfPath);
            $totalPages = $pdf->pageCount();

            for ($pageNumber = 1; $pageNumber <= min($totalPages, 10); $pageNumber++) {
                $pdf->selectPage($pageNumber);
                $imagePath = 'chapters/images/' . uniqid() . '_page_' . $pageNumber . '.jpg';
                $fullPath = storage_path('app/public/' . $imagePath);

                if (!file_exists(dirname($fullPath))) {
                    mkdir(dirname($fullPath), 0755, true);
                }

                $pdf->save($fullPath);

                $extractedImages[] = [
                    'page' => $pageNumber,
                    'path' => 'storage/' . $imagePath,
                    'caption' => "Figure de la page {$pageNumber}"
                ];
            }

        } catch (Exception $e) {

        }

        return $extractedImages;
    }

    private function generateCoverImage(string $pdfPath): string
    {
        try {
            $pdf = new Pdf($pdfPath);
            $pdf->selectPage(1);

            $coverPath = 'chapters/covers/' . uniqid() . '.jpg';
            $fullPath = storage_path('app/public/' . $coverPath);

            if (!file_exists(dirname($fullPath))) {
                mkdir(dirname($fullPath), 0755, true);
            }

            $pdf->save($fullPath);

            $image = Image::read($fullPath);
            $image->resize(400, null);
            $image->save($fullPath, 80);

            return 'storage/' . $coverPath;

        } catch (Exception $e) {
            return '';
        }
    }

    private function processPages(array $pages, array $options): string
    {
        $allContent = '';

        foreach ($pages as $index => $page) {
            $pageNumber = $index + 1;

            if (in_array($pageNumber, $options['ignoredPages'])) {
                continue;
            }

            $pageText = $page->getText();
            $processedText = $this->processPageContent($pageText, $pageNumber, $options);
            $allContent .= $processedText . "\n\n";
        }

        return $this->convertToMarkdown($this->cleanContent($allContent));
    }

    private function processPageContent(string $pageText, int $pageNumber, array $options): string
    {
        $lines = explode("\n", $pageText);
        $processedLines = [];
        $inCodeBlock = false;
        $codeBuffer = [];

        foreach ($lines as $line) {
            $trimmedLine = trim($line);

            if (empty($trimmedLine)) {
                if (!$inCodeBlock) {
                    $processedLines[] = '';
                }
                continue;
            }

            if ($options['ignorePageNumbers'] && $this->isPageNumber($trimmedLine)) {
                continue;
            }

            if ($options['extractCode'] && $this->isCodeLine($trimmedLine) && !$inCodeBlock) {
                if (!empty($codeBuffer)) {
                    $processedLines[] = $this->formatCodeBlock($codeBuffer);
                    $codeBuffer = [];
                }
                $inCodeBlock = true;
                $codeBuffer[] = $line;
                continue;
            }

            if ($inCodeBlock) {
                $codeBuffer[] = $line;
                if ($this->isEndOfCodeBlock($trimmedLine, $codeBuffer)) {
                    $processedLines[] = $this->formatCodeBlock($codeBuffer);
                    $codeBuffer = [];
                    $inCodeBlock = false;
                }
                continue;
            }

            $processedLines[] = $line;
        }

        if (!empty($codeBuffer)) {
            $processedLines[] = $this->formatCodeBlock($codeBuffer);
        }

        return implode("\n", $processedLines);
    }

    private function isPageNumber(string $line): bool
    {
        return preg_match('/^(Page\s+)?\d+(\s+of\s+\d+)?$/i', $line) ||
            preg_match('/^-\s*\d+\s*-$/', $line) ||
            (is_numeric($line) && strlen($line) <= 3);
    }

    private function isCodeLine(string $line): bool
    {
        foreach ($this->codePatterns as $pattern) {
            if (preg_match($pattern, $line)) {
                return true;
            }
        }
        return false;
    }

    private function formatCodeBlock(array $codeLines): string
    {
        $language = $this->detectCodeLanguage($codeLines);
        $code = implode("\n", $codeLines);
        return "\n```{$language}\n{$code}\n```\n";
    }

    private function detectCodeLanguage(array $codeLines): string
    {
        $code = implode(' ', $codeLines);

        $languages = [
            'php' => '/\$[a-zA-Z_]|<\?php/',
            'javascript' => '/function\s*\(|console\.log|var\s+|let\s+|const\s+/',
            'python' => '/def\s+|import\s+|print\s*\(/',
            'java' => '/public\s+class|import\s+java/',
            'c' => '/#include|int\s+main/',
            'kotlin' => '/fun\s+|var\s+|val\s+|class\s+/',
            'swift' => '/func\s+|var\s+|let\s+|struct\s+/',
            'dart' => '/class\s+|abstract\s+|enum\s+/',
            'html' => '/<\w+/',
        ];

        foreach ($languages as $lang => $pattern) {
            if (preg_match($pattern, $code)) {
                return $lang;
            }
        }

        return '';
    }

    private function isEndOfCodeBlock(string $line, array $codeBuffer): bool
    {
        $nonCodeLines = 0;
        $recentLines = array_slice($codeBuffer, -3);

        foreach ($recentLines as $recentLine) {
            if (!$this->isCodeLine(trim($recentLine)) && !empty(trim($recentLine))) {
                $nonCodeLines++;
            }
        }

        return $nonCodeLines >= 2 && !$this->isCodeLine($line);
    }

    private function convertToMarkdown(string $content): string
    {
        $lines = explode("\n", $content);
        $markdownLines = [];
        $previousLine = '';

        foreach ($lines as $line) {
            $line = trim($line);

            if (empty($line)) {
                continue;
            }

            if ($this->isTitle($line, $previousLine)) {
                $level = $this->getTitleLevel($line);
                $markdownLines[] = str_repeat('#', $level) . ' ' . $line;
            } elseif ($this->isBulletPoint($line)) {
                $markdownLines[] = '- ' . ltrim($line, '•-*• ');
            } elseif ($this->isNumberedList($line)) {
                $markdownLines[] = $line;
            } else {
                $markdownLines[] = $line;
            }

            $previousLine = $line;
        }

        return $this->formatMarkdownOutput($markdownLines);
    }

    private function isTitle(string $line, string $previousLine = ''): bool
    {
        if (preg_match('/^(\d+(\.\d+)*)\s+.+/', $line)) {
            return true;
        }

        if (strlen($line) > 5 && $line === strtoupper($line) &&
            preg_match('/^[A-ZÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞ\s\d\-\.]+$/', $line)) {
            return true;
        }

        return false;
    }

    private function getTitleLevel(string $line): int
    {
        if (preg_match('/^(\d+(\.\d+)*)\s+/', $line, $matches)) {
            $numbering = $matches[1];
            $level = substr_count($numbering, '.') + 1;
            return min($level, 6);
        }

        if (strlen($line) < 20 && $line === strtoupper($line)) {
            return 1;
        }

        return 2;
    }

    private function isBulletPoint(string $line): bool
    {
        return preg_match('/^[•\-\*]\s+/', $line);
    }

    private function isNumberedList(string $line): bool
    {
        return preg_match('/^\d+\.\s+/', $line);
    }

    private function formatMarkdownOutput(array $lines): string
    {
        $output = [];

        foreach ($lines as $line) {
            $isTitle = strpos($line, '#') === 0;

            if ($isTitle && !empty($output)) {
                $output[] = '';
            }

            $output[] = $line;

            if ($isTitle) {
                $output[] = '';
            }
        }

        return implode("\n", $output);
    }

    private function cleanContent(string $content): string
    {
        $lines = explode("\n", $content);
        $cleanedLines = [];

        foreach ($lines as $line) {
            $line = trim($line);

            if (empty($line) || $this->shouldIgnoreLine($line)) {
                continue;
            }

            if (strlen($line) < 3 && !$this->isImportantShortLine($line)) {
                continue;
            }

            $cleanedLines[] = $line;
        }

        return implode("\n", $cleanedLines);
    }

    private function shouldIgnoreLine(string $line): bool
    {
        foreach ($this->ignoredPatterns as $pattern) {
            if (preg_match($pattern, $line)) {
                return true;
            }
        }
        return false;
    }

    private function isImportantShortLine(string $line): bool
    {
        return preg_match('/^[A-Z0-9\s\-\.]{1,3}$/', $line) && !preg_match('/^\d+$/', $line);
    }

    private function generateTableOfContents(string $markdownContent): array
    {
        $lines = explode("\n", $markdownContent);
        $toc = [];

        foreach ($lines as $line) {
            if (preg_match('/^(#{1,6})\s+(.+)$/', $line, $matches)) {
                $level = strlen($matches[1]);
                $title = trim($matches[2]);
                $anchor = strtolower(str_replace([' ', '.', ',', '!', '?'], '-', $title));

                $toc[] = [
                    'level' => $level,
                    'title' => $title,
                    'anchor' => $anchor
                ];
            }
        }

        return $toc;
    }

    private function finalizeMarkdown(string $content, array $metadata, string $coverImage, array $toc, array $images): string
    {
        $finalMarkdown = '';

        if (!empty($metadata['title'])) {
            $finalMarkdown .= "# {$metadata['title']}\n\n";
        }

        if (!empty($coverImage)) {
            $finalMarkdown .= "![Couverture]({$coverImage})\n\n";
        }

        if (!empty($metadata['author'])) {
            $finalMarkdown .= "**Auteur:** {$metadata['author']}\n\n";
        }

        if (!empty($toc)) {
            $finalMarkdown .= "## Table des matières\n\n";
            foreach ($toc as $item) {
                $indent = str_repeat('  ', $item['level'] - 1);
                $finalMarkdown .= "{$indent}- [{$item['title']}](#{$item['anchor']})\n";
            }
            $finalMarkdown .= "\n";
        }

        $finalMarkdown .= $content;

        if (!empty($images)) {
            $finalMarkdown .= "\n\n## Images et Figures\n\n";
            foreach ($images as $image) {
                $finalMarkdown .= "### {$image['caption']}\n\n";
                $finalMarkdown .= "![{$image['caption']}]({$image['path']})\n\n";
            }
        }

        return $finalMarkdown;
    }

    private function calculateEstimatedDuration(string $content): int
    {
        $wordCount = str_word_count(strip_tags($content));
        return max(5, ceil($wordCount / 200));
    }
}

<?php

namespace App\Livewire;

use Exception;
use Illuminate\Contracts\View\View;
use Intervention\Image\Laravel\Facades\Image;
use Livewire\Attributes\Validate;
use Livewire\Component;
use Livewire\WithFileUploads;
use Smalot\PdfParser\Config;
use Smalot\PdfParser\Document;
use Smalot\PdfParser\Parser;
use Spatie\PdfToImage\Pdf;

class ConvertPdf extends Component
{
    use WithFileUploads;

    #[Validate('required|file|mimes:pdf|max:20480')]
    public $pdfFile;

    // Options de traitement
    public $extractImages = true;
    public $extractTables = true;
    public $extractCode = true;
    public $createTableOfContents = true;
    public $generateCoverImage = true;
    public $ignorePageNumbers = true;
    public $ignoredPages = []; // Pages à ignorer complètement

    // Progress tracking
    public $isProcessing = false;
    public $progress = 0;
    public $totalPages = 0;
    public $currentPage = 0;
    public $processingStep = 'initializing';

    // Results storage
    public $markdownContent = '';
    public $temporaryPath = '';
    public $metadata = [];
    public $extractedImages = [];
    public $extractedTables = [];
    public $tableOfContents = [];
    public $coverImagePath = '';

    private array $ignoredPatterns = [];
    private array $codePatterns = [];

    private array $strictCodePatterns = [];

    private array $lenientCodePatterns = [];
    private array $tablePatterns = [];

    public function mount(): void
    {
        $this->setupPatterns();
    }

    private function setupPatterns(): void
    {
        $this->ignoredPatterns = [
            // Numéros de page
            '/^Page \d+/i',
            '/^\d+$/',
            '/^- \d+ -$/',
            '/^Page \d+ of \d+/i',

            // Headers/footers communs
            '/^Copyright/i',
            '/^Confidential/i',
            '/^www\./i',
            '/^http[s]?:\/\//i',

            // Dates en footer
            '/^\d{1,2}\/\d{1,2}\/\d{4}$/',
            '/^\d{4}-\d{2}-\d{2}$/',

            // Texte répétitif
            '/^Powered by/i',
            '/^Generated by/i',
        ];

        // Patterns pour détecter du code
        $this->codePatterns = [
            '/^(function|def|class|public|private|protected)\s/',
            '/^(if|else|for|while|switch|case)\s*\(/',
            '/^(import|include|require|from)\s/',
            '/^(var|let|const|int|string|bool)\s/',
            '/^\s*{[\s\S]*}$/',
            '/^\s*<[^>]+>.*<\/[^>]+>$/', // HTML tags
            '/^\$[a-zA-Z_][a-zA-Z0-9_]*\s*=/', // PHP variables
            '/^console\.(log|error|warn)/',
            '/^#include|^#define/', // C/C++
        ];

        $this->strictCodePatterns = [
            '/^(function|def|class|public|private|protected)\s/',
            '/^(if|else|for|while|switch|case)\s*\(/',
            '/^(import|include|require|from)\s/',
            '/^(var|let|const|int|string|bool)\s/',
            '/^\$[a-zA-Z_][a-zA-Z0-9_]*\s*=/', // Variables PHP
            '/^console\.(log|error|warn)/',
            '/^#include|^#define/', // C/C++
        ];

        $this->lenientCodePatterns = [
            '/[{}();=<>]/', // Caractères typiques du code
            '/^\s*[\w]+\s*\(/', // Appels de fonction
            '/^\s*[\w]+\s*=/', // Affectations
        ];

        // Patterns pour détecter des tableaux
        $this->tablePatterns = [
            '/\|.*\|.*\|/', // Pipe-separated values
            '/\t.*\t.*\t/', // Tab-separated values
            '/^\s*\d+\.\s+.*\d+.*$/', // Numbered data rows
        ];
    }

    public function render(): View
    {
        return view('livewire.convert-pdf');
    }

    public function convertPdf(): void
    {
        $this->validate();
        $this->reset([
            'markdownContent', 'progress', 'currentPage', 'totalPages',
            'extractedImages', 'extractedTables', 'tableOfContents', 'coverImagePath'
        ]);
        $this->isProcessing = true;

        $this->temporaryPath = $this->pdfFile->getRealPath();

        try {
            // Générer l'image de couverture d'abord
            if ($this->generateCoverImage) {
                $this->processingStep = 'generating_cover';
                $this->generateCoverImage();
            }

            // Parser le PDF
            $config = app(Config::class);
            $config->setDataTmFontInfoHasToBeIncluded(true);
            $parser = new Parser([], $config);

            $this->processingStep = 'parsing';
            $document = $parser->parseFile($this->temporaryPath);
            $this->metadata = $this->extractMetadata($document);

            $pages = $document->getPages();
            $this->totalPages = count($pages);

            // Extraire les images si demandé
            if ($this->extractImages) {
                $this->processingStep = 'extracting_images';
                $this->extractImagesFromPdf();
            }

            // Traiter les pages
            $this->processPages($pages);

            // Créer la table des matières si demandé
            if ($this->createTableOfContents && empty($this->tableOfContents)) {
                $this->processingStep = 'creating_toc';
                $this->generateTableOfContents();
            }

            // Finaliser le markdown avec tous les éléments
            $this->processingStep = 'finalizing';
            $this->finalizeMarkdown();

        } catch (Exception $e) {
            $this->addError('processing', 'Error processing PDF: ' . $e->getMessage());
            $this->isProcessing = false;
        }
    }

    /**
     * Génère l'image de couverture
     */
    private function generateCoverImage(): void
    {
        try {
            $pdf = new Pdf($this->temporaryPath);
            $pdf->selectPage(1);

            $coverPath = 'covers/' . uniqid() . '.jpg';
            $fullPath = storage_path('app/public/' . $coverPath);

            // Créer le répertoire si nécessaire
            if (!file_exists(dirname($fullPath))) {
                mkdir(dirname($fullPath), 0755, true);
            }

            $pdf->save($fullPath);

            // Redimensionner l'image
            $image = Image::read($fullPath);
            $image->resize(400, null);
            $image->save($fullPath, 80);

            $this->coverImagePath = 'storage/' . $coverPath;

        } catch (Exception $e) {
            // Si ça échoue, on continue sans image de couverture
            $this->coverImagePath = '';
        }
    }

    /**
     * Extrait les métadonnées du PDF
     */
    private function extractMetadata(Document $pdf): array
    {
        $details = $pdf->getDetails();

        return [
            'title' => $details['Title'] ?? 'Document PDF',
            'author' => $details['Author'] ?? null,
            'subject' => $details['Subject'] ?? null,
            'creator' => $details['Creator'] ?? null,
            'producer' => $details['Producer'] ?? null,
            'creation_date' => $details['CreationDate'] ?? null,
            'modification_date' => $details['ModDate'] ?? null,
            'page_count' => count($pdf->getPages()),
        ];
    }

    /**
     * Extrait les images du PDF
     */
    private function extractImagesFromPdf(): void
    {
        try {
            $pdf = new Pdf($this->temporaryPath);
            $totalPages = $pdf->pageCount();

            for ($pageNumber = 1; $pageNumber <= $totalPages; $pageNumber++) {
                if (in_array($pageNumber, $this->ignoredPages)) {
                    continue;
                }

                $pdf->selectPage($pageNumber);
                $imagePath = 'extracts/images/' . uniqid() . '_page_' . $pageNumber . '.jpg';
                $fullPath = storage_path('app/public/' . $imagePath);

                if (!file_exists(dirname($fullPath))) {
                    mkdir(dirname($fullPath), 0755, true);
                }

                $pdf->save($fullPath);

                $this->extractedImages[] = [
                    'page' => $pageNumber,
                    'path' => 'storage/' . $imagePath,
                    'caption' => "Figure de la page {$pageNumber}"
                ];
            }

        } catch (Exception $e) {
            // Continue without images if extraction fails
        }
    }

    private function processPages(array $pages): void
    {
        $this->processingStep = 'processing_pages';
        $batchSize = 5;
        $allContent = '';

        foreach (array_chunk($pages, $batchSize) as $batchIndex => $pageBatch) {
            foreach ($pageBatch as $index => $page) {
                $this->currentPage = ($batchIndex * $batchSize) + $index + 1;

                // Ignorer les pages spécifiées
                if (in_array($this->currentPage, $this->ignoredPages)) {
                    continue;
                }

                $this->progress = round(($this->currentPage / $this->totalPages) * 80); // 80% pour le traitement des pages

                $pageText = $page->getText();

                // Analyser le contenu de la page
                $processedText = $this->processPageContent($pageText, $this->currentPage);
                $allContent .= $processedText . "\n\n";
            }

            // Mise à jour partielle du contenu
            $cleanedContent = $this->cleanContent($allContent);
            $this->markdownContent = $this->convertToMarkdown($cleanedContent);
            $this->dispatch('contentUpdated');
        }
    }

    /**
     * Traite le contenu d'une page spécifique
     */
    private function processPageContent(string $pageText, int $pageNumber): string
    {
        $lines = explode("\n", $pageText);
        $processedLines = [];
        $inCodeBlock = false;
        $inTable = false;
        $codeBuffer = [];
        $tableBuffer = [];

        foreach ($lines as $line) {
            $trimmedLine = trim($line);

            if (empty($trimmedLine)) {
                if (!$inCodeBlock && !$inTable) {
                    $processedLines[] = '';
                }
                continue;
            }

            // Ignorer les numéros de page si demandé
            if ($this->ignorePageNumbers && $this->isPageNumber($trimmedLine)) {
                continue;
            }

            // Détecter le début d'un bloc de code
            if ($this->isCodeLine($trimmedLine) && !$inCodeBlock) {
                if (!empty($codeBuffer)) {
                    $processedLines[] = $this->formatCodeBlock($codeBuffer);
                    $codeBuffer = [];
                }
                $inCodeBlock = true;
                $codeBuffer[] = $line;
                continue;
            }

            // Si on est dans un bloc de code
            if ($inCodeBlock) {
                $codeBuffer[] = $line;

                // Détecter la fin du bloc de code
                if ($this->isEndOfCodeBlock($trimmedLine, $codeBuffer)) {
                    $processedLines[] = $this->formatCodeBlock($codeBuffer);
                    $codeBuffer = [];
                    $inCodeBlock = false;
                }
                continue;
            }

            // Détecter les tableaux
            if ($this->extractTables && $this->isTableLine($trimmedLine)) {
                if (!$inTable) {
                    $inTable = true;
                }
                $tableBuffer[] = $line;
                continue;
            }

            // Si on était dans un tableau et qu'on n'y est plus
            if ($inTable && !$this->isTableLine($trimmedLine)) {
                if (!empty($tableBuffer)) {
                    $processedLines[] = $this->formatTable($tableBuffer, $pageNumber);
                    $tableBuffer = [];
                }
                $inTable = false;
            }

            // Ligne normale
            $processedLines[] = $line;
        }

        // Traiter les buffers restants
        if (!empty($codeBuffer)) {
            $processedLines[] = $this->formatCodeBlock($codeBuffer);
        }
        if (!empty($tableBuffer)) {
            $processedLines[] = $this->formatTable($tableBuffer, $pageNumber);
        }

        return implode("\n", $processedLines);
    }

    /**
     * Vérifie si une ligne est un numéro de page
     */
    private function isPageNumber(string $line): bool
    {
        return preg_match('/^(Page\s+)?\d+(\s+of\s+\d+)?$/i', $line) ||
            preg_match('/^-\s*\d+\s*-$/', $line) ||
            (is_numeric($line) && strlen($line) <= 3);
    }

    /**
     * Détecte si une ligne contient du code
     */
    private function isCodeLine(string $line, bool $strict = false): bool
    {
        $patterns = $strict ? $this->strictCodePatterns : array_merge($this->strictCodePatterns, $this->lenientCodePatterns);
        foreach ($patterns as $pattern) {
            if (preg_match($pattern, $line)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Formate un bloc de code en markdown
     */
    private function formatCodeBlock(array $codeLines): string
    {
        $language = $this->detectCodeLanguage($codeLines);
        $code = implode("\n", $codeLines);

        return "\n```{$language}\n{$code}\n```\n";
    }

    /**
     * Détecte le langage de programmation
     */
    private function detectCodeLanguage(array $codeLines): string
    {
        $code = implode(' ', $codeLines);

        if (preg_match('/\$[a-zA-Z_]/', $code) || preg_match('/<\?php/', $code)) {
            return 'php';
        }
        if (preg_match('/function\s*\(|console\.log|var\s+|let\s+|const\s+/', $code)) {
            return 'javascript';
        }
        if (preg_match('/def\s+|import\s+|print\s*\(/', $code)) {
            return 'python';
        }
        if (preg_match('/public\s+class|import\s+java/', $code)) {
            return 'java';
        }
        if (preg_match('/#include|int\s+main/', $code)) {
            return 'c';
        }
        if (preg_match('/fun\s+|var\s+|val\s+|class\s+|interface\s+|object\s+|package\s+|import\s+/', $code)) {
            return 'kotlin';
        }
        if (preg_match('/func\s+|var\s+|let\s+|struct\s+|class\s+|protocol\s+|extension\s+|enum\s+|import\s+/', $code)) {
            return 'swift';
        }
        if (preg_match('/class\s+|abstract\s+|enum\s+|interface\s+|mixin\s+|extension\s+|library\s+|mixin\s+|part\s+|factory\s+|typedef\s+|with\s+/', $code)) {
            return 'dart';
        }
        if (preg_match('/<\w+/', $code)) {
            return 'html';
        }
        return '';
    }

    /**
     * Détecte la fin d'un bloc de code
     */
    private function isEndOfCodeBlock(string $line, array $codeBuffer): bool
    {
        // Si on a plus de 3 lignes consécutives sans code, on termine le bloc
        $nonCodeLines = 0;
        $recentLines = array_slice($codeBuffer, -3);

        foreach ($recentLines as $recentLine) {
            if (!$this->isCodeLine(trim($recentLine)) && !empty(trim($recentLine))) {
                $nonCodeLines++;
            }
        }

        return $nonCodeLines >= 2 && !$this->isCodeLine($line);
    }

    /**
     * Détecte si une ligne fait partie d'un tableau
     */
    private function isTableLine(string $line): bool
    {
        foreach ($this->tablePatterns as $pattern) {
            if (preg_match($pattern, $line)) {
                return true;
            }
        }

        // Détecter des colonnes alignées
        if (preg_match('/\s{3,}/', $line) && str_word_count($line) >= 3) {
            return true;
        }

        return false;
    }

    /**
     * Formate un tableau en markdown
     */
    private function formatTable(array $tableLines, int $pageNumber): string
    {
        $this->extractedTables[] = [
            'page' => $pageNumber,
            'raw_content' => implode("\n", $tableLines)
        ];

        // Conversion simple en tableau markdown
        $markdown = "\n| Colonne 1 | Colonne 2 | Colonne 3 |\n";
        $markdown .= "|-----------|-----------|----------|\n";

        foreach ($tableLines as $line) {
            $line = trim($line);
            if (empty($line)) continue;

            // Séparer les colonnes (plusieurs stratégies)
            $cells = [];

            if (str_contains($line, '|')) {
                $cells = array_map('trim', explode('|', $line));
            } elseif (str_contains($line, "\t")) {
                $cells = array_map('trim', explode("\t", $line));
            } else {
                // Séparer par espaces multiples
                $cells = preg_split('/\s{2,}/', $line);
            }

            // Assurer au moins 3 colonnes
            while (count($cells) < 3) {
                $cells[] = '';
            }

            $markdown .= '| ' . implode(' | ', array_slice($cells, 0, 3)) . " |\n";
        }

        return $markdown . "\n";
    }

    private function cleanContent(string $content, array $options = []): string
    {
        $lines = explode("\n", $content);
        $cleanedLines = [];

        foreach ($lines as $line) {
            $line = trim($line);

            if (empty($line)) {
                continue;
            }

            if ($this->shouldIgnoreLine($line)) {
                continue;
            }

            if (strlen($line) < 3 && !$this->isImportantShortLine($line)) {
                continue;
            }

            $cleanedLines[] = $line;
        }

        return implode("\n", $cleanedLines);
    }

    private function shouldIgnoreLine(string $line): bool
    {
        foreach ($this->ignoredPatterns as $pattern) {
            if (preg_match($pattern, $line)) {
                return true;
            }
        }

        return false;
    }

    // Les méthodes existantes (cleanContent, convertToMarkdown, etc.) restent inchangées

    private function isImportantShortLine(string $line): bool
    {
        return preg_match('/^[A-Z0-9\s\-\.]{1,3}$/', $line) &&
            !preg_match('/^\d+$/', $line);
    }

    private function convertToMarkdown(string $content, array $options = []): string
    {
        $lines = explode("\n", $content);
        $markdownLines = [];
        $previousLine = '';
        $inList = false;
        $listLevel = 0;

        foreach ($lines as $line) {
            $line = trim($line);

            if (empty($line)) {
                if ($inList) {
                    $markdownLines[] = '';
                }
                continue;
            }

            // Détecter les niveaux de liste/points
            $currentListLevel = $this->getListLevel($line);

            if ($currentListLevel > 0) {
                $inList = true;
                $listLevel = $currentListLevel;
                $indent = str_repeat('  ', $listLevel - 1);
                $cleanLine = $this->cleanListItem($line);
                $markdownLines[] = $indent . '- ' . $cleanLine;
            } elseif ($this->isTitle($line, $previousLine)) {
                $inList = false;
                $level = $this->getTitleLevel($line);
                $markdownLines[] = str_repeat('#', $level) . ' ' . $line;
            } elseif ($this->isBulletPoint($line)) {
                $inList = true;
                $markdownLines[] = '- ' . ltrim($line, '•-*• ');
            } elseif ($this->isNumberedList($line)) {
                $inList = true;
                $markdownLines[] = $line;
            } else {
                $inList = false;
                $markdownLines[] = $line;
            }

            $previousLine = $line;
        }

        return $this->formatMarkdownOutput($markdownLines);
    }

    /**
     * Détecte le niveau de liste/sous-points
     */
    private function getListLevel(string $line): int
    {
        // Détecter l'indentation
        preg_match('/^(\s*)/', $line, $matches);
        $indentLength = strlen($matches[1]);

        // Détecter les marqueurs de liste
        if (preg_match('/^(\s*)([\d]+\.|\w\)|\w\.|\-|\*|\•)\s+/', $line, $matches)) {
            return max(1, intval($indentLength / 4) + 1);
        }

        return 0;
    }

    /**
     * Nettoie un élément de liste
     */
    private function cleanListItem(string $line): string
    {
        return preg_replace('/^(\s*)([\d]+\.|\w\)|\w\.|\-|\*|\•)\s+/', '', $line);
    }

    private function isTitle(string $line, string $previousLine = ''): bool
    {
        if (preg_match('/^(\d+(\.\d+)*)\s+.+/', $line)) {
            return true;
        }

        if (strlen($line) > 5 && $line === strtoupper($line) &&
            preg_match('/^[A-ZÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞ\s\d\-\.]+$/', $line)) {
            return true;
        }

        if (preg_match('/^[-=]{3,}$/', $previousLine)) {
            return true;
        }

        return false;
    }

    private function getTitleLevel(string $line): int
    {
        if (preg_match('/^(\d+(\.\d+)*)\s+/', $line, $matches)) {
            $numbering = $matches[1];
            $level = substr_count($numbering, '.') + 1;
            return min($level, 6);
        }

        if (strlen($line) < 20 && $line === strtoupper($line)) {
            return 1;
        }

        return 2;
    }

    private function isBulletPoint(string $line): bool
    {
        return preg_match('/^[•\-\*]\s+/', $line);
    }

    private function isNumberedList(string $line): bool
    {
        return preg_match('/^\d+\.\s+/', $line);
    }

    private function formatMarkdownOutput(array $lines): string
    {
        $output = [];
        $previousWasTitle = false;

        foreach ($lines as $line) {
            $isTitle = strpos($line, '#') === 0;

            if ($isTitle && !empty($output)) {
                $output[] = '';
            }

            $output[] = $line;

            if ($isTitle) {
                $output[] = '';
            }

            $previousWasTitle = $isTitle;
        }

        return implode("\n", $output);
    }

    /**
     * Génère la table des matières
     */
    private function generateTableOfContents(): void
    {
        $lines = explode("\n", $this->markdownContent);
        $toc = [];

        foreach ($lines as $line) {
            if (preg_match('/^(#{1,6})\s+(.+)$/', $line, $matches)) {
                $level = strlen($matches[1]);
                $title = trim($matches[2]);
                $anchor = strtolower(str_replace([' ', '.', ',', '!', '?'], '-', $title));

                $toc[] = [
                    'level' => $level,
                    'title' => $title,
                    'anchor' => $anchor
                ];
            }
        }

        $this->tableOfContents = $toc;
    }

    /**
     * Finalise le markdown avec tous les éléments
     */
    private function finalizeMarkdown(): void
    {
        $finalMarkdown = '';

        // Titre du document
        if (!empty($this->metadata['title'])) {
            $finalMarkdown .= "# {$this->metadata['title']}\n\n";
        }

        // Image de couverture
        if (!empty($this->coverImagePath)) {
            $finalMarkdown .= "![Couverture]({$this->coverImagePath})\n\n";
        }

        // Métadonnées
        if (!empty($this->metadata['author'])) {
            $finalMarkdown .= "**Auteur:** {$this->metadata['author']}\n\n";
        }

        // Table des matières
        if (!empty($this->tableOfContents)) {
            $finalMarkdown .= "## Table des matières\n\n";

            foreach ($this->tableOfContents as $item) {
                $indent = str_repeat('  ', $item['level'] - 1);
                $finalMarkdown .= "{$indent}- [{$item['title']}](#{$item['anchor']})\n";
            }
            $finalMarkdown .= "\n";
        }

        // Contenu principal
        $finalMarkdown .= $this->markdownContent;

        // Images extraites
        if (!empty($this->extractedImages)) {
            $finalMarkdown .= "\n\n## Images et Figures\n\n";

            foreach ($this->extractedImages as $image) {
                $finalMarkdown .= "### {$image['caption']}\n\n";
                $finalMarkdown .= "![{$image['caption']}]({$image['path']})\n\n";
            }
        }

        $this->markdownContent = $finalMarkdown;
        $this->processingStep = 'completed';
        $this->progress = 100;
        $this->isProcessing = false;
    }

    /**
     * Sauvegarde le résultat dans un fichier
     */
    public function saveMarkdown(): void
    {
        $filename = 'converted_' . time() . '.md';
        $path = storage_path('app/public/markdown/' . $filename);

        if (!file_exists(dirname($path))) {
            mkdir(dirname($path), 0755, true);
        }

        file_put_contents($path, $this->markdownContent);

        $this->dispatch('fileSaved', ['filename' => $filename, 'path' => 'storage/markdown/' . $filename]);
    }
}
